# 데이터베이스 트리거 (Database Trigger)
## 📌 정의

트리거는 데이터베이스에서 특정 이벤트가 발생했을 때 자동으로 실행되는 프로시저이다.

## 🔍 주요 특징

1. **실행 조건** 🎯
    - 특정 테이블에 대한 INSERT, UPDATE, DELETE 등의 DML 작업 수행 시 자동 실행
2. **실행 시점** ⏱️
    - BEFORE 트리거: 이벤트 발생 전 실행
    - AFTER 트리거: 이벤트 발생 후 실행
    - INSTEAD OF 트리거: 이벤트 대신 실행 (주로 뷰에 사용)
3. **유형** 🔢
    - 행 레벨 트리거: 영향 받는 각 행마다 실행
    - 문장 레벨 트리거: 전체 SQL 문에 대해 한 번만 실행

## 🎯 주요 용도

- 📊 데이터 무결성 유지
- 📏 업무 규칙 강제
- ✅ 복잡한 유효성 검사 수행
- 🔄 관련 테이블 자동 갱신
- 📝 감사 추적 및 로깅

## ✅ 장점

1. **데이터베이스 일관성 유지** 🏗️
    - 자동화된 규칙 적용으로 데이터 품질 보장
2. **애플리케이션 로직의 중앙 집중화** 🎯
    - 데이터베이스 레벨에서 비즈니스 규칙 구현
3. **보안 강화** 🔒
    - 데이터 변경에 대한 추가적인 제어 계층 제공

## ❌ 단점

1. **복잡성 증가** 🧩
    - 데이터베이스 구조와 로직이 복잡해질 수 있음
2. **성능 영향** ⚡
    - 과도한 사용 시 데이터베이스 성능 저하 가능
3. **디버깅 어려움** 🐛
    - 자동 실행으로 인한 문제 추적의 어려움

## 💻 구문 예시 (MySQL)

```sql
CREATE TRIGGER trigger_name
{BEFORE | AFTER} {INSERT | UPDATE | DELETE}
ON table_name
FOR EACH ROW
BEGIN
    -- 트리거 로직
END;

```

## 📊 트리거 사용 시나리오 비교

| 시나리오 | 장점 | 주의사항 |
| --- | --- | --- |
| 데이터 검증 | ✅ 일관된 규칙 적용 | ❗ 복잡한 검증은 성능 저하 가능 |
| 감사 로깅 | ✅ 자동화된 변경 추적 | ❗ 로그 테이블 크기 관리 필요 |
| 관련 테이블 갱신 | ✅ 데이터 일관성 보장 | ❗ 순환 참조 주의 |
| 계산된 열 갱신 | ✅ 실시간 데이터 정확성 | ❗ 빈번한 갱신 시 성능 영향 |

> 💡 Note: 트리거는 데이터베이스의 무결성을 유지하고 자동화된 작업을 수행하는 데 매우 유용한 도구다. 그러나 과도한 사용은 시스템 복잡성과 성능 저하를 초래할 수 있으므로 신중하게 설계하고 사용해야 한다.
>

## 🚀 모범 사례

1. 트리거는 간단하고 빠르게 유지
2. 트랜잭션 관리에 주의 (특히 여러 테이블 조작 시)
3. 재귀적 트리거 사용 시 주의 (무한 루프 가능성)
4. 트리거 동작을 문서화하여 유지보수성 향상
5. 성능 모니터링을 통해 트리거의 영향 평가

## 트리거 vs 스토어드 프로시저 비교
### 📊 주요 차이점 요약

| 특성 | 트리거 | 스토어드 프로시저 |
| --- | --- | --- |
| 실행 방식 | 🔄 자동 (이벤트 기반) | 🖱️ 명시적 호출 |
| 주요 용도 | 🛡️ 데이터 무결성, 규칙 강제 | 🧮 복잡한 비즈니스 로직 |
| 매개변수 | ❌ 불가능 | ✅ 입/출력 가능 |
| 트랜잭션 제어 | ❌ 불가능 | ✅ 가능 |
| 중첩 | ❌ 일반적으로 불가 | ✅ 가능 |
| 반환 값 | ❌ 불가능 | ✅ 가능 |
| 가시성과 제어 | 👁️‍🗨️ 암시적 (디버깅 어려움) | 🔍 명시적 (제어 용이) |

### 🔍 상세 비교

#### 1. 실행 방식 🚀

- **트리거:**
    - 특정 데이터베이스 이벤트(INSERT, UPDATE, DELETE 등) 발생 시 자동 실행
    - 예: 새 주문이 추가될 때마다 재고를 자동으로 업데이트
- **스토어드 프로시저:**
    - 사용자 또는 애플리케이션에 의해 명시적으로 호출되어 실행
    - 예: `CALL calculateTotalSales(2023);`

#### 2. 주요 용도 🎯

- **트리거:**
    - 데이터 무결성 유지
    - 업무 규칙 강제
    - 감사 추적
    - 관련 테이블 자동 업데이트
- **스토어드 프로시저:**
    - 복잡한 비즈니스 로직 수행
    - 대량 데이터 처리
    - 보고서 생성
    - 트랜잭션 관리

#### 3. 매개변수 📥📤

- **트리거:**
    - 매개변수를 받을 수 없음
    - 대신 NEW, OLD 같은 특수 테이블을 통해 데이터 액세스
- **스토어드 프로시저:**
    - 입력 매개변수를 받고 출력 매개변수를 반환할 수 있음
    - 다양한 데이터 타입의 매개변수 지원

#### 4. 트랜잭션 제어 🔐

- **트리거:**
    - COMMIT, ROLLBACK 등의 트랜잭션 제어문 사용 불가
    - 트리거를 발동시킨 트랜잭션의 일부로 실행됨
- **스토어드 프로시저:**
    - 트랜잭션 제어문 (COMMIT, ROLLBACK, SAVEPOINT 등) 사용 가능
    - 독립적인 트랜잭션 관리 가능

#### 5. 중첩 🎭

- **트리거:**
    - 일반적으로 다른 트리거 내에서 직접 호출 불가
    - 간접적인 중첩은 가능할 수 있으나 DBMS에 따라 제한적
- **스토어드 프로시저:**
    - 다른 프로시저 내에서 호출 가능
    - 재귀적 호출도 가능 (주의 필요)

#### 6. 반환 값 🔙

- **트리거:**
    - 값을 직접 반환할 수 없음
    - 데이터 변경을 통해 간접적으로 결과 전달
- **스토어드 프로시저:**
    - 하나 이상의 값을 반환할 수 있음
    - 결과셋 반환 가능

#### 7. 가시성과 제어 👁️

- **트리거:**
    - 암시적으로 실행되어 디버깅이 어려울 수 있음
    - 실행 시점과 횟수를 직접 제어하기 어려움
- **스토어드 프로시저:**
    - 명시적으로 호출되어 제어와 디버깅이 상대적으로 용이
    - 실행 시점과 횟수를 정확히 제어 가능

### 💡 선택 가이드

- **트리거 사용 적합 상황:**
    - 데이터 변경 시 자동으로 관련 작업을 수행해야 할 때
    - 데이터 무결성을 데이터베이스 레벨에서 강제해야 할 때
    - 감사 로그를 자동으로 생성해야 할 때
- **스토어드 프로시저 사용 적합 상황:**
    - 복잡한 비즈니스 로직을 데이터베이스에서 처리해야 할 때
    - 여러 애플리케이션에서 공통으로 사용되는 데이터베이스 작업이 있을 때
    - 대량의 데이터를 효율적으로 처리해야 할 때
    - 보안상 중요한 작업을 캡슐화해야 할 때

> 📌 Note: 트리거와 스토어드 프로시저는 각각 고유한 장단점을 가지고 있으며, 상황에 따라 적절하게 선택하여 사용해야 한다. 때로는 두 가지를 조합하여 사용하는 것이 가장 효과적일 수 있다.
>